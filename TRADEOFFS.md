# Tradeoffs

[Lodash](https://lodash.com/) is brilliantly engineered, well maintained and documented, and designed to be highly performant even over very large data structures. So why would you ever need Just?

## Short, simplified answer
* Use __Lodash__ if it covers an edge case you care about (Lodash is _very_ good at covering edge cases)
* Use __Lodash__ if your app is going to be processing vast datastructures (100,000+ records). 
* Use __Lodash__, [__Underscore__](http://underscorejs.org/) or [__Ramda__](http://ramdajs.com/) if they provide a method that Just doesn't (and there are many).
* If none of the above apply and you care about JavaScript footprint, use __Just__.

## Why does JavaScript footprint matter?

[Alex Russell](https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/) puts it better than I could:

> We regularly see sites loading more than 500KB of script (compressed). This matters because all script loading delays the metric we value most: Time to Interactive. Sites with this much script are simply inaccessible to a broad swath of the world’s users; statistically, users do not (and will not) wait for these experiences to load. Those that do experience horrendous jank.

JavaScript size is especially critical for mobile web development. As Alex points out, 45% of mobile connections occur over 2G worldwide. 75% of of connections occur on either 2G or 3G.

## How Big are Just utils?

Just modules are hand written so they include only essential code. All of them come in at well under 1kB minfied/gzipped[¹](#¹Data). Lodash Modularized modules are generated by inlining all their dependencies, meaning they share a lot of redundant code and are generally much bigger.  

## How robust are Just utils?

Most Just utils pass all Lodash unit tests for the functionality they are designed to support. The following utils only failed on subjective behaviors (notably argument coercion which Just is not intended to support). Failing tests are noted against each util.

Every Just utility comes in at well under 1K minified/gzipped[¹](#¹Data). While 

| Just  (size)   |  Lodash   (Size) | Lodash tests which Just fails |
| ---------------| -----------------|-------------------------------|
| just-split  (145b)  | chunk (756b)        | PASS√π¬  |
| just-tail (48b) | tail (111b)  |  PASS√å  |
| just-flatten-it (99b) |flattendeep (549b) | PASS√å   |
| just-intersect (115b) | intersection (361b)  | FAIL∞∫   |
| just-unique | uniq | PASS√å |
| just-zip-it | zip |  PASS√å•  |
| just-compact  (84b)  | compact (53b) | PASS√å   |
| just-curry (72b) | curry (2860b)  |  PASS√≠…  |
| just-partial-it (98b) | partial (2940b) | PASS√†  |
| just-once (78b) | once (465b) |  PASS√  |
| just-clamp | clamp      |  PASS√µƒ  |
| just-safe-get | get      |  PASS˙  |
| just-safe-set | set      |  PASS˙  |
| just-map-values | mapValues      |  PASS√¬π˚  |
| just-map-keys | mapKeys      |  PASS√¬π˚  |
| just-omit | omit      |  PASS√¶≥˚å  |
| just-pick | pick      |  PASS√¶≥˚  |
| just-values | values      | PASS¶  |
| just-camel-case | camelCase      | PASS√  |
| just-kebab-case | kebabCase      | PASS√   |
| just-snake-case | snakeCase      | PASS√   |
| just-left-pad | padStart      |  PASS≈√  |
| just-right-pad | padEnd      |  PASS≈√  |
| just-range | range      | PASS   |
| just-truncate | truncate      | FAIL§   |
| just-debounce | debounce      | FAIL   |
| just-merge | merge      |  FAIL |
| just-throttle | throttle      | FAIL  |
| just-clone | cloneDeep      | FAIL   |


† `instance of` on instances of partial  
√ argument coercion
¶ expects object not falsey value as argument  
π expects number arg (doesn't support coercion)   
¬ doesn't defer to other lodash utils
π doesn't use `_.identity` when predicate function is nullish
˚ should work with `_.property` shorthands  
å doesn't work with arguments in lieu of arrays  
∞ NaN not equal  
∫ non-unique results
• zip([[],[]]) => [[[]], [[]]] (as per http://osteele.com/sources/javascript/functional/)
µ should work without lower bound arg
ƒ if outer bounds are NaN should coerce to 0
˙ follows dotty re. get(obj, ['a.b'])
≈ trunctates from right, not left
§ lodash truncate is bizaare (e.g. default 30)
≥ doesn't flatten `pick(obj, ['a', 'b'], 'c')`
≠should support placeholders (see partial)
…can not be used as a constructor

truncate issues
no separator arg
30 default

merge issues
∆ should work as an iteratee for methods like `_.reduce`
æ should not assign values that are the same as their destinations
÷ should merge sources containing circular references
« should treat sparse array sources as dense
≠ should merge typed arrays
º should deep clone array/typed-array/plain-object sources
œ should not augment source objects
¡ should merge plain-objects onto non plain-objects
™ should skip merging when `object` and `source` are the same value



* Load speed
* Dependency management
* truly modular
* Less Battle Tested
* Edge cases
* Perf with large collections
* Randomness
* LoDash meant to compete with ES methods for perf

##### ¹Size data generated by [package-size](https://github.com/egoist/package-size).

